(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-leaflet"));
	else if(typeof define === 'function' && define.amd)
		define([, ], factory);
	else if(typeof exports === 'object')
		exports["ReactLeafletArrowheads"] = factory(require("react"), require("react-leaflet"));
	else
		root["ReactLeafletArrowheads"] = factory(root["React"], root[undefined]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_leaflet__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/react-leaflet-arrowheads.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js":
/*!*******************************************************************!*\
  !*** ./node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _leaflet_geometryutil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./leaflet-geometryutil.js */ \"./node_modules/leaflet-arrowheads/src/leaflet-geometryutil.js\");\n/* harmony import */ var _leaflet_geometryutil_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_leaflet_geometryutil_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction modulus(i, n){\n   return (i % n + n) % n;\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (L.Polyline.include({\n\n   arrowheads: function(options = {}){\n\n      // Merge user input options with default options:\n      const defaults = {\n         yawn: 60,\n         size: '15%',\n         frequency: 'allvertices',\n         proportionalToTotal: false,\n      }\n\n      this.options.noClip = true;\n\n      let actualOptions = Object.assign({}, defaults, options)\n      this._arrowheadOptions = actualOptions;\n\n      this._hatsApplied = true;\n      return this;\n   },\n\n   buildVectorHats: function( options ){\n\n      // Reset variables from previous this._update()\n      if (this._arrowheads){\n         this._arrowheads.remove()\n         let arrowheads = []\n         let allhats = []\n      }\n\n      //  -------------------------------------------------------- //\n      //  ------------  FILTER THE OPTIONS ----------------------- //\n      /*\n         * The next 3 lines folds the options of the parent polyline into the default options for all polylines\n         * The options for the arrowhead are then folded in as well\n         * All options defined in parent polyline will be inherited by the arrowhead, unless otherwise specified in the arrowhead(options) call\n      */\n\n\n      let defaultOptionsOfParent = Object.getPrototypeOf(Object.getPrototypeOf(this.options))\n\n      // merge default options of parent polyline (this.options's prototype's prototype) with options passed to parent polyline (this.options).\n      let parentOptions = Object.assign({}, defaultOptionsOfParent, this.options)\n\n      // now merge in the options the user has put in the arrowhead call\n      let hatOptions = Object.assign({}, parentOptions, options)\n\n      // ...with a few exceptions:\n      hatOptions.smoothFactor = 1\n      hatOptions.fillOpacity = 1\n      hatOptions.fill = options.fill ? true : false\n      hatOptions.interactive = false\n\n      //  ------------  FILTER THE OPTIONS END -------------------- //\n      //  --------------------------------------------------------- //\n\n\n\n\n\n      //  --------------------------------------------------------- //\n      //  ------ LOOP THROUGH EACH POLYLINE SEGMENT --------------- //\n      //  ------ TO CALCULATE HAT SIZES AND CAPTURE IN ARRAY ------ //\n\n      let size = options.size.toString(); // stringify if its a number\n      let allhats = []; // empty array to receive hat polylines\n      const { frequency } = options;\n\n\n      this._parts.forEach( (peice, index) => {\n\n         // Immutable variables for each peice\n         const latlngs = peice.map( point => this._map.layerPointToLatLng(point));\n\n         const totalLength = ( () => {\n            let total = 0;\n            for (var i = 0; i < peice.length-1; i++) {\n               total += this._map.distance(latlngs[i], latlngs[i+1])\n            }\n            return total;\n         })();\n\n\n         // TBD by options if tree below\n         let derivedLatLngs;\n         let derivedBearings;\n         let spacing;\n         let noOfPoints;\n\n\n         //  Determining latlng and bearing arrays based on frequency choice:\n         if ( !isNaN(frequency) ) {\n\n            spacing = 1 / frequency;\n            noOfPoints = frequency;\n\n         } else if ( frequency.toString().slice( frequency.toString().length - 1, frequency.toString().length ) === '%' ){\n\n            console.log('Error: arrowhead frequency option cannot be given in percent.  Try another unit.');\n\n         } else if ( frequency.toString().slice( frequency.toString().length - 1, frequency.toString().length ) === 'm' ){\n\n            spacing = frequency.slice(0,frequency.length-1) / totalLength;\n            noOfPoints = 1 / spacing\n            // round things out for more even spacing:\n            noOfPoints = Math.floor(noOfPoints)\n            spacing = 1 / noOfPoints\n\n         } else if ( frequency.toString().slice( frequency.toString().length - 2, frequency.toString().length ) === 'px' ){\n\n            spacing = ( () => {\n\n               let chosenFrequency = frequency.slice(0,frequency.length-2)\n               let refPoint1 = this._map.getCenter()\n               let xy1 = this._map.latLngToLayerPoint( refPoint1 )\n               let xy2 = {\n                  x: xy1.x + Number(chosenFrequency),\n                  y: xy1.y\n               }\n               let refPoint2 = this._map.layerPointToLatLng( xy2 )\n               let derivedMeters = this._map.distance(refPoint1, refPoint2)\n               return derivedMeters / totalLength;\n            })()\n\n            noOfPoints = 1 / spacing\n\n            // round things out for more even spacing:\n            noOfPoints = Math.floor(noOfPoints)\n            spacing = 1 / noOfPoints\n\n\n         }\n\n\n         if (options.frequency === 'allvertices'){\n\n            derivedBearings = ( () => {\n               let bearings = [];\n               for (var i = 1; i < latlngs.length; i++) {\n                  let bearing = L.GeometryUtil.bearing(\n                     latlngs[ modulus( (i-1), latlngs.length ) ], latlngs[i]\n                  ) + 180\n                  bearings.push(bearing)\n               }\n               return bearings;\n            })()\n\n            derivedLatLngs = latlngs\n            derivedLatLngs.shift()\n\n         } else if (options.frequency === 'endonly') {\n\n            derivedLatLngs = [\n               latlngs[latlngs.length - 1]\n            ];\n\n            derivedBearings = [\n               L.GeometryUtil.bearing(\n                  latlngs[latlngs.length - 2], latlngs[latlngs.length - 1]\n               ) + 180\n            ];\n\n         } else {\n\n            derivedLatLngs = []\n            let interpolatedPoints = []\n            for (var i = 0; i < noOfPoints; i++) {\n\n               let interpolatedPoint = L.GeometryUtil.interpolateOnLine(\n                  this._map, latlngs, spacing * (i + 1)\n               )\n\n               interpolatedPoints.push(interpolatedPoint)\n               derivedLatLngs.push(interpolatedPoint.latLng)\n\n            }\n\n            derivedBearings = ( () => {\n               let bearings = [];\n\n               for (var i = 0; i < interpolatedPoints.length; i++) {\n                  let bearing = L.GeometryUtil.bearing(\n                     interpolatedPoints[i].latLng, latlngs[ interpolatedPoints[i].predecessor ]\n                  )\n                  bearings.push(bearing)\n               }\n               return bearings;\n            })()\n\n         }\n\n\n         let n = latlngs.length - 1\n         let hats = [];\n\n         // Function to build hats based on index and a given hatsize in meters\n         const pushHats = (size) => {\n\n            let leftWingPoint =\n               L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] - options.yawn/2, size)\n\n            let rightWingPoint =\n               L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] + options.yawn/2, size)\n\n            let hatPoints = [\n                  [leftWingPoint.lat, leftWingPoint.lng],\n                  [derivedLatLngs[i].lat, derivedLatLngs[i].lng],\n                  [rightWingPoint.lat, rightWingPoint.lng]\n               ]\n\n            let hat = options.fill\n               ? L.polygon(hatPoints, hatOptions)\n               : L.polyline(hatPoints, hatOptions)\n\n            hats.push(hat)\n\n         } // pushHats()\n\n\n         // Function to build hats based on pixel input\n         const pushHatsFromPixels = (size) => {\n\n            let sizePixels = size.slice(0, size.length-2)\n\n            let derivedXY = this._map.latLngToLayerPoint(derivedLatLngs[i])\n\n            let bearing = derivedBearings[i]\n\n            let thetaLeft = (180 - bearing - options.yawn/2) * (Math.PI / 180),\n               thetaRight = (180 -bearing + options.yawn/2) * (Math.PI / 180)\n\n            let dxLeft = sizePixels * Math.sin(thetaLeft),\n               dyLeft = sizePixels * Math.cos(thetaLeft),\n               dxRight =sizePixels * Math.sin(thetaRight),\n               dyRight =sizePixels * Math.cos(thetaRight)\n\n            let leftWingXY = {\n               x: derivedXY.x + dxLeft,\n               y: derivedXY.y + dyLeft\n            }\n            let rightWingXY = {\n               x: derivedXY.x + dxRight,\n               y: derivedXY.y + dyRight\n            }\n\n            let leftWingPoint = this._map.layerPointToLatLng(leftWingXY),\n               rightWingPoint = this._map.layerPointToLatLng(rightWingXY)\n\n            let hatPoints = [\n                  [leftWingPoint.lat, leftWingPoint.lng],\n                  [derivedLatLngs[i].lat, derivedLatLngs[i].lng],\n                  [rightWingPoint.lat, rightWingPoint.lng]\n               ]\n\n            let hat = options.fill\n               ? L.polygon(hatPoints, hatOptions)\n               : L.polyline(hatPoints, hatOptions)\n\n            hats.push(hat)\n\n         } // pushHatsFromPixels()\n\n\n         //  -------  LOOP THROUGH POINTS IN EACH SEGMENT ---------- //\n         for (var i = 0; i < derivedLatLngs.length; i++) {\n\n            // ---- If size is chosen in meters -------------------------\n            if (size.slice(size.length-1, size.length) === 'm' ){\n\n               let hatSize = size.slice(0, size.length-1)\n               pushHats(hatSize)\n\n            // ---- If size is chosen in percent ------------------------\n            } else if (size.slice(size.length-1, size.length) === '%' ){\n\n               let sizePercent = size.slice(0, size.length-1)\n               let hatSize = ( () => {\n                  if (options.frequency === 'endonly' && options.proportionalToTotal){\n                     return totalLength * sizePercent / 100;\n                  } else {\n                     let averageDistance = ( totalLength / (peice.length-1) )\n                     return averageDistance * sizePercent / 100\n                  }\n               })() // hatsize calculation\n\n               pushHats( hatSize );\n\n            // ---- If size is chosen in pixels --------------------------\n            } else if ( size.slice(size.length-2, size.length) === 'px' ){\n\n               pushHatsFromPixels(options.size)\n\n            // ---- If size unit is not given -----------------------------\n            } else {\n\n               console.log(\n                  'Error: Arrowhead size unit not defined.  Check your arrowhead options.'\n               )\n\n            }  // if else block for Size\n\n\n         } // for loop for each point witin a peice\n\n         allhats.push(...hats);\n\n      }) // forEach peice\n\n      //  --------- LOOP THROUGH EACH POLYLINE END ---------------- //\n      //  --------------------------------------------------------- //\n\n\n      let arrowheads = L.layerGroup(allhats)\n      this._arrowheads = arrowheads;\n\n      return this\n\n   },\n\n\n   getArrowheads: function(){\n      if (this._arrowheads){\n         return this._arrowheads;\n      } else {\n         return console.log(`Error: You tried to call '.getArrowheads() on a shape that does not have a arrowhead.  Use '.arrowheads()' to add a arrowheads before trying to call '.getArrowheads()'`);\n      }\n   },\n\n   deleteArrowheads: function(){\n\n      if (this._arrowheads){\n         this._arrowheads.remove()\n         delete this._arrowheads;\n         delete this._arrowheadOptions;\n         this._hatsApplied = false;\n      }\n\n   },\n\n\n   addTo: function (map) {\n      map.addLayer(this);\n      if (this._hatsApplied){\n         this.buildVectorHats(this._arrowheadOptions);\n         this._arrowheads.addTo(this._map)\n      }\n      return this;\n   },\n\n\n   _update: function () {\n\t\tif (!this._map) { return; }\n\n      this._clipPoints();\n\t\tthis._simplifyPoints();\n\t\tthis._updatePath();\n\n\n      if (this._hatsApplied){\n         this.buildVectorHats(this._arrowheadOptions);\n         this._map.addLayer(this._arrowheads);\n      }\n\t},\n\n\n   remove: function () {\n\n      if (this._arrowheads){\n         this._arrowheads.removeFrom(this._map || this._mapToAdd);\n         this._arrowheads = []\n      }\n      return this.removeFrom(this._map || this._mapToAdd);\n   },\n\n\n}));\n\n\n\nL.LayerGroup.include({\n\n   removeLayer: function (layer) {\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\n\n\t\tif (this._map && this._layers[id]) {\n         if (this._layers[id]._arrowheads){\n            this._layers[id]._arrowheads.remove() ;\n         }\n\t\t\tthis._map.removeLayer(this._layers[id]);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\treturn this;\n\t},\n\n\n   onRemove: function (map, layer) {\n\n      for (var layer in this._layers) {\n         if (this._layers[layer]){\n            this._layers[layer].remove()\n         }\n      }\n\n      this.eachLayer(map.removeLayer, map);\n\n   },\n\n\n})\n\n\n//# sourceURL=webpack://ReactLeafletArrowheads/./node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js?");

/***/ }),

/***/ "./node_modules/leaflet-arrowheads/src/leaflet-geometryutil.js":
/*!*********************************************************************!*\
  !*** ./node_modules/leaflet-arrowheads/src/leaflet-geometryutil.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("L.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n\t// true if it's a flat array of latlngs; false if nested\n\treturn !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n/**\n* @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n* @name L.GeometryUtil\n*/\n\nL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\n\t/**\n\t\t Shortcut function for planar distance between two {L.LatLng} at current zoom.\n\t\t @tutorial distance-length\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {L.LatLng} latlngA geographical point A\n\t\t @param {L.LatLng} latlngB geographical point B\n\t\t @returns {Number} planar distance\n\t */\n\tdistance: function (map, latlngA, latlngB) {\n\t\t return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n\t},\n\n\t/**\n\t\t Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {L.LatLng} latlng - The position to search\n\t\t @param {L.LatLng} latlngA geographical point A of the segment\n\t\t @param {L.LatLng} latlngB geographical point B of the segment\n\t\t @returns {Number} planar distance\n\t*/\n\tdistanceSegment: function (map, latlng, latlngA, latlngB) {\n\t\t var p = map.latLngToLayerPoint(latlng),\n\t\t\t p1 = map.latLngToLayerPoint(latlngA),\n\t\t\t p2 = map.latLngToLayerPoint(latlngB);\n\t\t return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n\t},\n\n\t/**\n\t\t Shortcut function for converting distance to readable distance.\n\t\t @param {Number} distance distance to be converted\n\t\t @param {String} unit 'metric' or 'imperial'\n\t\t @returns {String} in yard or miles\n\t*/\n\treadableDistance: function (distance, unit) {\n\t\t var isMetric = (unit !== 'imperial'),\n\t\t\t  distanceStr;\n\t\t if (isMetric) {\n\t\t\t  // show metres when distance is < 1km, then show km\n\t\t\t  if (distance > 1000) {\n\t\t\t\t\tdistanceStr = (distance  / 1000).toFixed(2) + ' km';\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t\tdistanceStr = Math.ceil(distance) + ' m';\n\t\t\t  }\n\t\t }\n\t\t else {\n\t\t\t  distance *= 1.09361;\n\t\t\t  if (distance > 1760) {\n\t\t\t\t\tdistanceStr = (distance / 1760).toFixed(2) + ' miles';\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\t\tdistanceStr = Math.ceil(distance) + ' yd';\n\t\t\t  }\n\t\t }\n\t\t return distanceStr;\n\t},\n\n\t/**\n\t\t Returns true if the latlng belongs to segment A-B\n\t\t @param {L.LatLng} latlng - The position to search\n\t\t @param {L.LatLng} latlngA geographical point A of the segment\n\t\t @param {L.LatLng} latlngB geographical point B of the segment\n\t\t @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n\t\t @returns {boolean}\n\t */\n\tbelongsSegment: function(latlng, latlngA, latlngB, tolerance) {\n\t\t tolerance = tolerance === undefined ? 0.2 : tolerance;\n\t\t var hypotenuse = latlngA.distanceTo(latlngB),\n\t\t\t  delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n\t\t return delta/hypotenuse < tolerance;\n\t},\n\n\t/**\n\t * Returns total length of line\n\t * @tutorial distance-length\n\t *\n\t * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n\t * @returns {Number} Total length (pixels for Point, meters for LatLng)\n\t */\n\tlength: function (coords) {\n\t\t var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n\t\t return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;\n\t},\n\n\t/**\n\t * Returns a list of accumulated length along a line.\n\t * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n\t * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n\t */\n\taccumulatedLengths: function (coords) {\n\t\t if (typeof coords.getLatLngs == 'function') {\n\t\t\t  coords = coords.getLatLngs();\n\t\t }\n\t\t if (coords.length === 0)\n\t\t\t  return [];\n\t\t var total = 0,\n\t\t\t  lengths = [0];\n\t\t for (var i = 0, n = coords.length - 1; i< n; i++) {\n\t\t\t  total += coords[i].distanceTo(coords[i+1]);\n\t\t\t  lengths.push(total);\n\t\t }\n\t\t return lengths;\n\t},\n\n\t/**\n\t\t Returns the closest point of a {L.LatLng} on the segment (A-B)\n\t\t @tutorial closest\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {L.LatLng} latlng - The position to search\n\t\t @param {L.LatLng} latlngA geographical point A of the segment\n\t\t @param {L.LatLng} latlngB geographical point B of the segment\n\t\t @returns {L.LatLng} Closest geographical point\n\t*/\n\tclosestOnSegment: function (map, latlng, latlngA, latlngB) {\n\t\t var maxzoom = map.getMaxZoom();\n\t\t if (maxzoom === Infinity)\n\t\t\t  maxzoom = map.getZoom();\n\t\t var p = map.project(latlng, maxzoom),\n\t\t\t p1 = map.project(latlngA, maxzoom),\n\t\t\t p2 = map.project(latlngB, maxzoom),\n\t\t\t closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n\t\t return map.unproject(closest, maxzoom);\n\t},\n\n\t/**\n\t\t Returns the closest latlng on layer.\n\t\t Accept nested arrays\n\t\t @tutorial closest\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n\t\t @param {L.LatLng} latlng - The position to search\n\t\t @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n\t\t @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n\t*/\n\tclosest: function (map, layer, latlng, vertices) {\n\n\t\t var latlngs,\n\t\t\t  mindist = Infinity,\n\t\t\t  result = null,\n\t\t\t  i, n, distance, subResult;\n\n\t\t if (layer instanceof Array) {\n\t\t\t  // if layer is Array<Array<T>>\n\t\t\t  if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n\t\t\t\t\t// if we have nested arrays, we calc the closest for each array\n\t\t\t\t\t// recursive\n\t\t\t\t\tfor (i = 0; i < layer.length; i++) {\n\t\t\t\t\t\t subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n\t\t\t\t\t\t if (subResult && subResult.distance < mindist) {\n\t\t\t\t\t\t\t  mindist = subResult.distance;\n\t\t\t\t\t\t\t  result = subResult;\n\t\t\t\t\t\t }\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t  } else if (layer[0] instanceof L.LatLng\n\t\t\t\t\t\t\t  || typeof layer[0][0] === 'number'\n\t\t\t\t\t\t\t  || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n\t\t\t\t\tlayer = L.polyline(layer);\n\t\t\t  } else {\n\t\t\t\t\treturn result;\n\t\t\t  }\n\t\t }\n\n\t\t // if we don't have here a Polyline, that means layer is incorrect\n\t\t // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n\t\t if (! ( layer instanceof L.Polyline ) )\n\t\t\t  return result;\n\n\t\t // deep copy of latlngs\n\t\t latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n\t\t // add the last segment for L.Polygon\n\t\t if (layer instanceof L.Polygon) {\n\t\t\t  // add the last segment for each child that is a nested array\n\t\t\t  var addLastSegment = function(latlngs) {\n\t\t\t\t\tif (L.Polyline._flat(latlngs)) {\n\t\t\t\t\t\t latlngs.push(latlngs[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t for (var i = 0; i < latlngs.length; i++) {\n\t\t\t\t\t\t\t  addLastSegment(latlngs[i]);\n\t\t\t\t\t\t }\n\t\t\t\t\t}\n\t\t\t  };\n\t\t\t  addLastSegment(latlngs);\n\t\t }\n\n\t\t // we have a multi polygon / multi polyline / polygon with holes\n\t\t // use recursive to explore and return the good result\n\t\t if ( ! L.Polyline._flat(latlngs) ) {\n\t\t\t  for (i = 0; i < latlngs.length; i++) {\n\t\t\t\t\t// if we are at the lower level, and if we have a L.Polygon, we add the last segment\n\t\t\t\t\tsubResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n\t\t\t\t\tif (subResult.distance < mindist) {\n\t\t\t\t\t\t mindist = subResult.distance;\n\t\t\t\t\t\t result = subResult;\n\t\t\t\t\t}\n\t\t\t  }\n\t\t\t  return result;\n\n\t\t } else {\n\n\t\t\t  // Lookup vertices\n\t\t\t  if (vertices) {\n\t\t\t\t\tfor(i = 0, n = latlngs.length; i < n; i++) {\n\t\t\t\t\t\t var ll = latlngs[i];\n\t\t\t\t\t\t distance = L.GeometryUtil.distance(map, latlng, ll);\n\t\t\t\t\t\t if (distance < mindist) {\n\t\t\t\t\t\t\t  mindist = distance;\n\t\t\t\t\t\t\t  result = ll;\n\t\t\t\t\t\t\t  result.distance = distance;\n\t\t\t\t\t\t }\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t  }\n\n\t\t\t  // Keep the closest point of all segments\n\t\t\t  for (i = 0, n = latlngs.length; i < n-1; i++) {\n\t\t\t\t\tvar latlngA = latlngs[i],\n\t\t\t\t\t\t latlngB = latlngs[i+1];\n\t\t\t\t\tdistance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n\t\t\t\t\tif (distance <= mindist) {\n\t\t\t\t\t\t mindist = distance;\n\t\t\t\t\t\t result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n\t\t\t\t\t\t result.distance = distance;\n\t\t\t\t\t}\n\t\t\t  }\n\t\t\t  return result;\n\t\t }\n\n\t},\n\n\t/**\n\t\t Returns the closest layer to latlng among a list of layers.\n\t\t @tutorial closest\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {Array<L.ILayer>} layers Set of layers\n\t\t @param {L.LatLng} latlng - The position to search\n\t\t @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n\t*/\n\tclosestLayer: function (map, layers, latlng) {\n\t\t var mindist = Infinity,\n\t\t\t  result = null,\n\t\t\t  ll = null,\n\t\t\t  distance = Infinity;\n\n\t\t for (var i = 0, n = layers.length; i < n; i++) {\n\t\t\t  var layer = layers[i];\n\t\t\t  if (layer instanceof L.LayerGroup) {\n\t\t\t\t\t// recursive\n\t\t\t\t\tvar subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n\t\t\t\t\tif (subResult.distance < mindist) {\n\t\t\t\t\t\t mindist = subResult.distance;\n\t\t\t\t\t\t result = subResult;\n\t\t\t\t\t}\n\t\t\t  } else {\n\t\t\t\t\t// Single dimension, snap on points, else snap on closest\n\t\t\t\t\tif (typeof layer.getLatLng == 'function') {\n\t\t\t\t\t\t ll = layer.getLatLng();\n\t\t\t\t\t\t distance = L.GeometryUtil.distance(map, latlng, ll);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t ll = L.GeometryUtil.closest(map, layer, latlng);\n\t\t\t\t\t\t if (ll) distance = ll.distance;  // Can return null if layer has no points.\n\t\t\t\t\t}\n\t\t\t\t\tif (distance < mindist) {\n\t\t\t\t\t\t mindist = distance;\n\t\t\t\t\t\t result = {layer: layer, latlng: ll, distance: distance};\n\t\t\t\t\t}\n\t\t\t  }\n\t\t }\n\t\t return result;\n\t},\n\n\t/**\n\t\t Returns the n closest layers to latlng among a list of input layers.\n\t\t @param {L.Map} map - Leaflet map to be used for this method\n\t\t @param {Array<L.ILayer>} layers - Set of layers\n\t\t @param {L.LatLng} latlng - The position to search\n\t\t @param {?Number} [n=layers.length] - the expected number of output layers.\n\t\t @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n\t*/\n\tnClosestLayers: function (map, layers, latlng, n) {\n\t\t n = typeof n === 'number' ? n : layers.length;\n\n\t\t if (n < 1 || layers.length < 1) {\n\t\t\t  return null;\n\t\t }\n\n\t\t var results = [];\n\t\t var distance, ll;\n\n\t\t for (var i = 0, m = layers.length; i < m; i++) {\n\t\t\t  var layer = layers[i];\n\t\t\t  if (layer instanceof L.LayerGroup) {\n\t\t\t\t\t// recursive\n\t\t\t\t\tvar subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n\t\t\t\t\tresults.push(subResult);\n\t\t\t  } else {\n\t\t\t\t\t// Single dimension, snap on points, else snap on closest\n\t\t\t\t\tif (typeof layer.getLatLng == 'function') {\n\t\t\t\t\t\t ll = layer.getLatLng();\n\t\t\t\t\t\t distance = L.GeometryUtil.distance(map, latlng, ll);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t ll = L.GeometryUtil.closest(map, layer, latlng);\n\t\t\t\t\t\t if (ll) distance = ll.distance;  // Can return null if layer has no points.\n\t\t\t\t\t}\n\t\t\t\t\tresults.push({layer: layer, latlng: ll, distance: distance});\n\t\t\t  }\n\t\t }\n\n\t\t results.sort(function(a, b) {\n\t\t\t  return a.distance - b.distance;\n\t\t });\n\n\t\t if (results.length > n) {\n\t\t\t  return results.slice(0, n);\n\t\t } else  {\n\t\t\t  return results;\n\t\t }\n\t},\n\n\t/**\n\t * Returns all layers within a radius of the given position, in an ascending order of distance.\n\t\t@param {L.Map} map Leaflet map to be used for this method\n\t\t@param {Array<ILayer>} layers - A list of layers.\n\t\t@param {L.LatLng} latlng - The position to search\n\t\t@param {?Number} [radius=Infinity] - Search radius in pixels\n\t\t@return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n\t */\n\tlayersWithin: function(map, layers, latlng, radius) {\n\t  radius = typeof radius == 'number' ? radius : Infinity;\n\n\t  var results = [];\n\t  var ll = null;\n\t  var distance = 0;\n\n\t  for (var i = 0, n = layers.length; i < n; i++) {\n\t\t var layer = layers[i];\n\n\t\t if (typeof layer.getLatLng == 'function') {\n\t\t\t  ll = layer.getLatLng();\n\t\t\t  distance = L.GeometryUtil.distance(map, latlng, ll);\n\t\t }\n\t\t else {\n\t\t\t  ll = L.GeometryUtil.closest(map, layer, latlng);\n\t\t\t  if (ll) distance = ll.distance;  // Can return null if layer has no points.\n\t\t }\n\n\t\t if (ll && distance < radius) {\n\t\t\t  results.push({layer: layer, latlng: ll, distance: distance});\n\t\t }\n\t  }\n\n\t  var sortedResults = results.sort(function(a, b) {\n\t\t\treturn a.distance - b.distance;\n\t  });\n\n\t  return sortedResults;\n\t},\n\n\t/**\n\t\t Returns the closest position from specified {LatLng} among specified layers,\n\t\t with a maximum tolerance in pixels, providing snapping behaviour.\n\t\t @tutorial closest\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {Array<ILayer>} layers - A list of layers to snap on.\n\t\t @param {L.LatLng} latlng - The position to snap\n\t\t @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n\t\t @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n\t\t @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n\t*/\n\tclosestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n\t\t tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n\t\t withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n\n\t\t var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n\t\t if (!result || result.distance > tolerance)\n\t\t\t  return null;\n\n\t\t // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n\t\t if (withVertices && typeof result.layer.getLatLngs == 'function') {\n\t\t\t  var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n\t\t\t  if (closest.distance < tolerance) {\n\t\t\t\t\tresult.latlng = closest;\n\t\t\t\t\tresult.distance = L.GeometryUtil.distance(map, closest, latlng);\n\t\t\t  }\n\t\t }\n\t\t return result;\n\t},\n\n\t/**\n\t\t Returns the Point located on a segment at the specified ratio of the segment length.\n\t\t @param {L.Point} pA coordinates of point A\n\t\t @param {L.Point} pB coordinates of point B\n\t\t @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n\t\t @returns {L.Point} the interpolated point.\n\t*/\n\tinterpolateOnPointSegment: function (pA, pB, ratio) {\n\t\t return L.point(\n\t\t\t  (pA.x * (1 - ratio)) + (ratio * pB.x),\n\t\t\t  (pA.y * (1 - ratio)) + (ratio * pB.y)\n\t\t );\n\t},\n\n\t/**\n\t\t Returns the coordinate of the point located on a line at the specified ratio of the line length.\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n\t\t @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n\t\t @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n\t\t (-1 if the interpolated point is the first vertex)\n\t*/\n\tinterpolateOnLine: function (map, latLngs, ratio) {\n\t\t latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;\n\t\t var n = latLngs.length;\n\t\t if (n < 2) {\n\t\t\t  return null;\n\t\t }\n\n\t\t // ensure the ratio is between 0 and 1;\n\t\t ratio = Math.max(Math.min(ratio, 1), 0);\n\n\t\t if (ratio === 0) {\n\t\t\t  return {\n\t\t\t\t\tlatLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n\t\t\t\t\tpredecessor: -1\n\t\t\t  };\n\t\t }\n\t\t if (ratio == 1) {\n\t\t\t  return {\n\t\t\t\t\tlatLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),\n\t\t\t\t\tpredecessor: latLngs.length - 2\n\t\t\t  };\n\t\t }\n\n\t\t // project the LatLngs as Points,\n\t\t // and compute total planar length of the line at max precision\n\t\t var maxzoom = map.getMaxZoom();\n\t\t if (maxzoom === Infinity)\n\t\t\t  maxzoom = map.getZoom();\n\t\t var pts = [];\n\t\t var lineLength = 0;\n\t\t for(var i = 0; i < n; i++) {\n\t\t\t  pts[i] = map.project(latLngs[i], maxzoom);\n\t\t\t  if(i > 0)\n\t\t\t\t lineLength += pts[i-1].distanceTo(pts[i]);\n\t\t }\n\n\t\t var ratioDist = lineLength * ratio;\n\n\t  // follow the line segments [ab], adding lengths,\n\t\t // until we find the segment where the points should lie on\n\t  var cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;\n\t  for (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n\t\t  var pointA = pts[i], pointB = pts[i+1];\n\n\t\t  cumulativeDistanceToA = cumulativeDistanceToB;\n\t\t  cumulativeDistanceToB += pointA.distanceTo(pointB);\n\t  }\n\t  \n\t  if (pointA == undefined && pointB == undefined) { // Happens when line has no length\n\t\t  var pointA = pts[0], pointB = pts[1], i = 1;\n\t  }\n\n\t  // compute the ratio relative to the segment [ab]\n\t  var segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;\n\t  var interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n\t  return {\n\t\t  latLng: map.unproject(interpolatedPoint, maxzoom),\n\t\t  predecessor: i-1\n\t  };\n\t},\n\n\t/**\n\t\t Returns a float between 0 and 1 representing the location of the\n\t\t closest point on polyline to the given latlng, as a fraction of total line length.\n\t\t (opposite of L.GeometryUtil.interpolateOnLine())\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {L.PolyLine} polyline Polyline on which the latlng will be search\n\t\t @param {L.LatLng} latlng The position to search\n\t\t @returns {Number} Float between 0 and 1\n\t*/\n\tlocateOnLine: function (map, polyline, latlng) {\n\t\t var latlngs = polyline.getLatLngs();\n\t\t if (latlng.equals(latlngs[0]))\n\t\t\t  return 0.0;\n\t\t if (latlng.equals(latlngs[latlngs.length-1]))\n\t\t\t  return 1.0;\n\n\t\t var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n\t\t\t  lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n\t\t\t  total_length = lengths[lengths.length-1],\n\t\t\t  portion = 0,\n\t\t\t  found = false;\n\t\t for (var i=0, n = latlngs.length-1; i < n; i++) {\n\t\t\t  var l1 = latlngs[i],\n\t\t\t\t\tl2 = latlngs[i+1];\n\t\t\t  portion = lengths[i];\n\t\t\t  if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.0001)) {\n\t\t\t\t\tportion += l1.distanceTo(point);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t }\n\t\t if (!found) {\n\t\t\t  throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n\t\t }\n\t\t return portion / total_length;\n\t},\n\n\t/**\n\t\t Returns a clone with reversed coordinates.\n\t\t @param {L.PolyLine} polyline polyline to reverse\n\t\t @returns {L.PolyLine} polyline reversed\n\t*/\n\treverse: function (polyline) {\n\t\t return L.polyline(polyline.getLatLngs().slice(0).reverse());\n\t},\n\n\t/**\n\t\t Returns a sub-part of the polyline, from start to end.\n\t\t If start is superior to end, returns extraction from inverted line.\n\t\t @param {L.Map} map Leaflet map to be used for this method\n\t\t @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n\t\t @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n\t\t @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n\t\t @returns {Array<L.LatLng>} new polyline\n\t */\n\textract: function (map, polyline, start, end) {\n\t\t if (start > end) {\n\t\t\t  return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);\n\t\t }\n\n\t\t // Bound start and end to [0-1]\n\t\t start = Math.max(Math.min(start, 1), 0);\n\t\t end = Math.max(Math.min(end, 1), 0);\n\n\t\t var latlngs = polyline.getLatLngs(),\n\t\t\t  startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n\t\t\t  endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n\t\t // Return single point if start == end\n\t\t if (start == end) {\n\t\t\t  var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n\t\t\t  return [point.latLng];\n\t\t }\n\t\t // Array.slice() works indexes at 0\n\t\t if (startpoint.predecessor == -1)\n\t\t\t  startpoint.predecessor = 0;\n\t\t if (endpoint.predecessor == -1)\n\t\t\t  endpoint.predecessor = 0;\n\t\t var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);\n\t\t result.unshift(startpoint.latLng);\n\t\t result.push(endpoint.latLng);\n\t\t return result;\n\t},\n\n\t/**\n\t\t Returns true if first polyline ends where other second starts.\n\t\t @param {L.PolyLine} polyline First polyline\n\t\t @param {L.PolyLine} other Second polyline\n\t\t @returns {bool}\n\t*/\n\tisBefore: function (polyline, other) {\n\t\t if (!other) return false;\n\t\t var lla = polyline.getLatLngs(),\n\t\t\t  llb = other.getLatLngs();\n\t\t return (lla[lla.length-1]).equals(llb[0]);\n\t},\n\n\t/**\n\t\t Returns true if first polyline starts where second ends.\n\t\t @param {L.PolyLine} polyline First polyline\n\t\t @param {L.PolyLine} other Second polyline\n\t\t @returns {bool}\n\t*/\n\tisAfter: function (polyline, other) {\n\t\t if (!other) return false;\n\t\t var lla = polyline.getLatLngs(),\n\t\t\t  llb = other.getLatLngs();\n\t\t return (lla[0]).equals(llb[llb.length-1]);\n\t},\n\n\t/**\n\t\t Returns true if first polyline starts where second ends or start.\n\t\t @param {L.PolyLine} polyline First polyline\n\t\t @param {L.PolyLine} other Second polyline\n\t\t @returns {bool}\n\t*/\n\tstartsAtExtremity: function (polyline, other) {\n\t\t if (!other) return false;\n\t\t var lla = polyline.getLatLngs(),\n\t\t\t  llb = other.getLatLngs(),\n\t\t\t  start = lla[0];\n\t\t return start.equals(llb[0]) || start.equals(llb[llb.length-1]);\n\t},\n\n\t/**\n\t\t Returns horizontal angle in degres between two points.\n\t\t @param {L.Point} a Coordinates of point A\n\t\t @param {L.Point} b Coordinates of point B\n\t\t @returns {Number} horizontal angle\n\t */\n\tcomputeAngle: function(a, b) {\n\t\t return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n\t},\n\n\t/**\n\t\tReturns slope (Ax+B) between two points.\n\t\t @param {L.Point} a Coordinates of point A\n\t\t @param {L.Point} b Coordinates of point B\n\t\t @returns {Object} with ``a`` and ``b`` properties.\n\t */\n\tcomputeSlope: function(a, b) {\n\t\t var s = (b.y - a.y) / (b.x - a.x),\n\t\t\t  o = a.y - (s * a.x);\n\t\t return {'a': s, 'b': o};\n\t},\n\n\t/**\n\t\tReturns LatLng of rotated point around specified LatLng center.\n\t\t @param {L.LatLng} latlngPoint: point to rotate\n\t\t @param {double} angleDeg: angle to rotate in degrees\n\t\t @param {L.LatLng} latlngCenter: center of rotation\n\t\t @returns {L.LatLng} rotated point\n\t */\n\trotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {\n\t\t var maxzoom = map.getMaxZoom();\n\t\t if (maxzoom === Infinity)\n\t\t\t  maxzoom = map.getZoom();\n\t\t var angleRad = angleDeg*Math.PI/180,\n\t\t\t  pPoint = map.project(latlngPoint, maxzoom),\n\t\t\t  pCenter = map.project(latlngCenter, maxzoom),\n\t\t\t  x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,\n\t\t\t  y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;\n\t\t return map.unproject(new L.Point(x2,y2), maxzoom);\n\t},\n\n\t/**\n\t\tReturns the bearing in degrees clockwise from north (0 degrees)\n\t\tfrom the first L.LatLng to the second, at the first LatLng\n\t\t@param {L.LatLng} latlng1: origin point of the bearing\n\t\t@param {L.LatLng} latlng2: destination point of the bearing\n\t\t@returns {float} degrees clockwise from north.\n\t*/\n\tbearing: function(latlng1, latlng2) {\n\t\t var rad = Math.PI / 180,\n\t\t\t  lat1 = latlng1.lat * rad,\n\t\t\t  lat2 = latlng2.lat * rad,\n\t\t\t  lon1 = latlng1.lng * rad,\n\t\t\t  lon2 = latlng2.lng * rad,\n\t\t\t  y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n\t\t\t  x = Math.cos(lat1) * Math.sin(lat2) -\n\t\t\t\t\tMath.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n\t\t var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n\t\t return bearing >= 180 ? bearing-360 : bearing;\n\t},\n\n\t/**\n\t\tReturns the point that is a distance and heading away from\n\t\tthe given origin point.\n\t\t@param {L.LatLng} latlng: origin point\n\t\t@param {float} heading: heading in degrees, clockwise from 0 degrees north.\n\t\t@param {float} distance: distance in meters\n\t\t@returns {L.latLng} the destination point.\n\t\tMany thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n\t\tfor a great reference and examples.\n\t*/\n\tdestination: function(latlng, heading, distance) {\n\t\t heading = (heading + 360) % 360;\n\t\t var rad = Math.PI / 180,\n\t\t\t  radInv = 180 / Math.PI,\n\t\t\t  R = 6378137, // approximation of Earth's radius\n\t\t\t  lon1 = latlng.lng * rad,\n\t\t\t  lat1 = latlng.lat * rad,\n\t\t\t  rheading = heading * rad,\n\t\t\t  sinLat1 = Math.sin(lat1),\n\t\t\t  cosLat1 = Math.cos(lat1),\n\t\t\t  cosDistR = Math.cos(distance / R),\n\t\t\t  sinDistR = Math.sin(distance / R),\n\t\t\t  lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n\t\t\t\t\tsinDistR * Math.cos(rheading)),\n\t\t\t  lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n\t\t\t\t\tcosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n\t\t lon2 = lon2 * radInv;\n\t\t lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n\t\t return L.latLng([lat2 * radInv, lon2]);\n\t},\n\n\t/**\n\t\tReturns the the angle of the given segment and the Equator in degrees,\n\t\tclockwise from 0 degrees north.\n\t\t@param {L.Map} map: Leaflet map to be used for this method\n\t\t@param {L.LatLng} latlngA: geographical point A of the segment\n\t\t@param {L.LatLng} latlngB: geographical point B of the segment\n\t\t@returns {Float} the angle in degrees.\n\t*/\n\tangle: function(map, latlngA, latlngB) {\n\t  var pointA = map.latLngToContainerPoint(latlngA),\n\t\t\tpointB = map.latLngToContainerPoint(latlngB),\n\t\t\tangleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n\t  angleDeg += angleDeg < 0 ? 360 : 0;\n\t  return angleDeg;\n\t},\n\n\t/**\n\t\tReturns a point snaps on the segment and heading away from the given origin point a distance.\n\t\t@param {L.Map} map: Leaflet map to be used for this method\n\t\t@param {L.LatLng} latlngA: geographical point A of the segment\n\t\t@param {L.LatLng} latlngB: geographical point B of the segment\n\t\t@param {float} distance: distance in meters\n\t\t@returns {L.latLng} the destination point.\n\t*/\n\tdestinationOnSegment: function(map, latlngA, latlngB, distance) {\n\t  var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n\t\t\tlatlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n\t  return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n\t},\n});\n\n\n//# sourceURL=webpack://ReactLeafletArrowheads/./node_modules/leaflet-arrowheads/src/leaflet-geometryutil.js?");

/***/ }),

/***/ "./src/react-leaflet-arrowheads.js":
/*!*****************************************!*\
  !*** ./src/react-leaflet-arrowheads.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-leaflet */ \"react-leaflet\");\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_leaflet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet_arrowheads__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet-arrowheads */ \"./node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar ArrowheadsPolyline =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ArrowheadsPolyline, _React$Component);\n\n  function ArrowheadsPolyline() {\n    _classCallCheck(this, ArrowheadsPolyline);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ArrowheadsPolyline).apply(this, arguments));\n  }\n\n  _createClass(ArrowheadsPolyline, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var polyline = this.polylineRef.leafletElement;\n\n      if (this.props.arrowheads) {\n        polyline.arrowheads(this.props.arrowheads);\n\n        polyline._update();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_leaflet__WEBPACK_IMPORTED_MODULE_1__[\"Polyline\"], _extends({}, this.props, {\n        ref: function ref(polylineRef) {\n          return _this.polylineRef = polylineRef;\n        }\n      }));\n    }\n  }]);\n\n  return ArrowheadsPolyline;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ArrowheadsPolyline);\n\n//# sourceURL=webpack://ReactLeafletArrowheads/./src/react-leaflet-arrowheads.js?");

/***/ }),

/***/ "react":
/*!************************************************************************!*\
  !*** external {"commonjs":"react","commonjs2":"react","root":"React"} ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n\n//# sourceURL=webpack://ReactLeafletArrowheads/external_%7B%22commonjs%22:%22react%22,%22commonjs2%22:%22react%22,%22root%22:%22React%22%7D?");

/***/ }),

/***/ "react-leaflet":
/*!***********************************************************************************************!*\
  !*** external {"commonjs":"react-leaflet","commonjs2":"react-leaflet","Root":"ReactLeaflet"} ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_react_leaflet__;\n\n//# sourceURL=webpack://ReactLeafletArrowheads/external_%7B%22commonjs%22:%22react-leaflet%22,%22commonjs2%22:%22react-leaflet%22,%22Root%22:%22ReactLeaflet%22%7D?");

/***/ })

/******/ });
});